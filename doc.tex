    % voorbeelddocument voor Inleiding Informatiekunde
    % alles wat volgt achter een procentteken is commentaar 
    % en wordt genegeerd bij de verwerking van het document

    % definitie van de documentklasse (artikel) en de fontgrootte (11 punten) 
    \documentclass[11pt]{article}
    \usepackage[utf8]{inputenc}  % gebruik de juiste 'character encoding'
    \usepackage[T1]{fontenc}
    \usepackage[spanish]{babel}    % definitie van de taal (Engels is de standaard)
    \usepackage{hyperref}        % geef URLs netjes weer
    \usepackage[spanish]{cleveref}
    \usepackage{booktabs}		 % mooiere tabellen
    \usepackage[a4paper,margin=2cm]{geometry}
    \pagestyle{empty}            % zet paginanummering uit
    \usepackage{graphicx}
    \usepackage{float}


    \usepackage{listings}
    \usepackage{caption}
    \usepackage{minted}
    \usemintedstyle{vs} % o: monokai, tango, friendly, colorful


    \title{Actividad experimental: comparación empírica entre multiplicación estándar y Strassen}
    \author{Lic. Alex Maglio Neyra Herrada}
    \date{(2025 MAES DIS) -- Maestría en Ciencias de la Computación\\
    Algoritmos y Estructura de Datos GA}

    \begin{document}

    \maketitle                  
    \thispagestyle{empty}       

    \begin{quote}
    Se utilizó Inteligencia Artificial con fines de apoyo, revisión y retroalimentación. La implementación, el análisis y el contenido fueron realizados por el autor.
    \end{quote}


    \section{Introducción}

    Las diapositivas del curso del MIT sobre Divide and Conquer indican que, aunque Strassen reduce el exponente teórico de la multiplicación de matrices (≈ \(n^{2.81}\)), en la práctica suele comenzar a superar a la multiplicación estándar recién a partir de cierto umbral (típicamente alrededor de \(n\ge 32\), según implementación y máquina) \cite{mit06strassen}.

    El objetivo de este trabajo es comprobar empíricamente esa afirmación y estimar el valor empírico \(N_0\) a partir del cual la versión de Strassen implementada aquí supera en tiempo a la multiplicación estándar. Para asegurar reproductibilidad se usaron:

    \begin{itemize}
    \item tamaños \(n\) potencias de dos (8,16,32,\dots,4096),
    \item matrices generadas con semilla fija (comprobando además matrices aleatorias, nulas e identidad),
    \item mediciones repetidas por tamaño (número de repeticiones dependiente de \(n\)) y estadístico usado = media.
    \end{itemize}

    En lo siguiente se resumen la implementación (código usado), los resultados principales (gráfica para matrices aleatorias) y una breve discusión sobre por qué el \(N_0\) empírico puede diferir del valor teórico sugerido.


    \section{Implementación}

    A continuación se muestran los fragmentos representativos de las implementaciones usadas en el experimento: la multiplicación estándar (tres bucles) y la implementación recursiva de Strassen con un umbral de caso base.

    \begin{listing}
    \caption{Multiplicación estándar (fila × columna), C = A × B.}
    \label{lst:std}
    \begin{minted}[linenos, frame=lines]{cpp}
    Matrix StandardMultiplication::multiply(const Matrix &A, const Matrix &B)
    {
        size_t n = A.n;
        Matrix C(n);
        for (size_t i = 0; i < n; ++i) {
            for (size_t k = 0; k < n; ++k) {
                double aik = A(i,k);
                for (size_t j = 0; j < n; ++j)
                    C(i,j) += aik * B(k,j);
            }
        }
        return C;
    }
    \end{minted}
    \end{listing}

    \begin{listing}
    \caption{Implementación recursiva de Strassen (simplificada; caso base: usar estándar para \(n\le threshold\)).}
    \label{lst:strassen}
    \begin{minted}[linenos, frame=lines]{cpp}
    Matrix Strassen::multiply(const Matrix &A, const Matrix &B, size_t threshold)
    {
        if (A.n <= threshold) return StandardMultiplication::multiply(A,B);
        size_t m = A.n/2; // asumimos potencias de dos
        // construir A11,A12,A21,A22 y B11..B22 (ver código completo en src/benchmark)
        // calcular M1..M7 recursivamente y recomponer C11..C22
        // devolver C
    }
    \end{minted}
    \end{listing}

    El código completo se encuentra en el repositorio (archivos `standard_multiplication.*` y `strassen.*`). Se verificó la corrección numérica comparando los resultados de ambas implementaciones para cada par de matrices (tolerancia \(1e-6\)).

    La compilación se realizó con optimización \texttt{-O3} y las mediciones se repitieron varias veces por tamaño para reducir ruido (estadístico reportado: media de tiempos en nanosegundos).

Los datos de las entradas (matrices) se generaron con semilla fija para garantizar reproducibilidad. Se consideraron tres tipos de matrices: \emph{Random} (valores reales en \([-10,10]\)), \emph{Zero} y \emph{Identity}; los tamaños evaluados fueron potencias de dos (8,16,32,...,4096).

Para reducir ruido, cada medición se repitió varias veces (el número de repeticiones depende de \(n\)) y se reporta la media de los tiempos en nanosegundos.


    \section{Resultados}

    \begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{outputs/plots/Random.png}
    \caption{Tiempos (media en ns) para matrices aleatorias (semilla fija). Escala en \(x\) = potencias de dos (log2).}
    \label{fig:random}
    \end{figure}

A continuación se presentan los resultados principales del experimento con matrices aleatorias.

    \medskip



    A partir del experimento con matrices aleatorias (Figura~\ref{fig:random}) estimamos el umbral empírico donde Strassen empieza a superar a la multiplicación estándar. En nuestros datos el cruce ocurre aproximadamente en:

    \begin{center}
    \(N_0 \approx 2^{9} = 512\).
    \end{center}

    Se llevaron a cabo además dos experimentos complementarios (matrices \emph{Zero} e \emph{Identity}) para validar la estabilidad del comportamiento; en resumen, la posición de \(N_0\) varía con el tipo de entrada y con el umbral recursivo elegido, pero la observación central se mantiene: el beneficio de Strassen aparece en tamaños relativamente grandes en nuestra implementación y máquina.

    \begin{table}[H]
    \centering
    \begin{tabular}{r r r r r}
    \toprule
    $n$ & Std mean (ns) & Strassen mean (ns) & ratio (std/str) & Faster \\
    \midrule
    8    & 127       & 127       & 1.00   & Standard \\
    16   & 706       & 739       & 0.96   & Standard \\
    32   & 4356      & 4208      & 1.04   & Strassen \\
    64   & 25875     & 35522     & 0.73   & Standard \\
    128  & 202208    & 304922    & 0.66   & Standard \\
    256  & 1595242   & 2069342   & 0.77   & Standard \\
    512  & 17303754  & 15312856  & 1.13   & Strassen \\
    1024 & 167481446 & 116891440 & 1.43   & Strassen \\
    \bottomrule
    \end{tabular}
    \caption{Resultados para el caso 'Random' (valores medios en ns, extraídos de `tabulated_values/O3/benchmark/benchmark_results.csv`).}
    \end{table}


    Reflexión sobre los resultados y limitaciones:

    \begin{itemize}
    \item Observación principal: en nuestra implementación y máquina, Strassen supera a la multiplicación estándar para \(n\gtrsim 512\). Esto difiere del umbral \(\approx 32\) mencionado en algunas referencias, lo cual es esperable por razones prácticas.
    \item Posibles causas: sobrecoste por creación/copia de matrices temporales (add/sub), muchas asignaciones de memoria, overhead recursivo y menor aprovechamiento de vectorización/BLAS en la versión de Strassen, además del caso base (threshold) utilizado para dejar de recursar.
    \item Limitaciones del experimento: resultados dependientes de la máquina, del compilador y de la implementación; mediciones grandes (\(n\ge 512\)) tienen menos repeticiones por tiempo; no se usó BLAS optimizada en la multiplicación estándar.
    \item Recomendaciones: para refinar \(N_0\) se recomienda barrer el parámetro \texttt{threshold}, implementar vistas (offset+stride) para evitar copias, y comparar contra una implementación bloqueada o BLAS (\texttt{dgemm}).
    \end{itemize}

    Con esto cerramos la sección de resultados y discusión.\section{Conclusiones}

    Breve resumen:

    \begin{itemize}
    \item Diseño experimental: se compararon dos implementaciones en C++ (multiplicación estándar y Strassen), usando potencias de dos (8..4096), generación reproducible de matrices (Random/Zero/Identity), y repeticiones por tamaño; el código fuente está en el repositorio.
    \item Resultado principal: para matrices aleatorias y la implementación usada, el umbral empírico donde Strassen empieza a ser más rápido es aproximadamente \(N_0 \approx 2^{9}=512\).
    \item Interpretación: la diferencia con el umbral teórico pequeño se explica por constantes ocultas (sumas/restas y copias temporales), overhead de recursión y efectos de memoria/cache; optimizaciones (reducción de copias, uso de vistas o BLAS) pueden mover \(N_0\) hacia tamaños menores.
    \item Limitaciones: resultados dependientes de la máquina, compilador y heurísticos de caso base; para generalizar se recomienda barrer \texttt{threshold} y comparar con implementaciones optimizadas (bloqueada/BLAS).
    \end{itemize}

    En conjunto, el experimento muestra la importancia de evaluar implementaciones concretas: la ventaja asintótica de Strassen se hace evidente, pero sólo después de que su overhead se amortiza en entradas lo suficientemente grandes.

    \bibliographystyle{plain}
    \bibliography{biblio}


    \end{document}
